# 任务一
1. 类图与时序图（所有的类图只标注了类的public方法，任务二三同）  
    类图为 S191220100/uml/task1_class.pu  
    时序图为 S191220100/uml/task1_timeLine.pu  
2. example设计  
    将问题涉及到的实体都抽象成对象，将对象的行为抽象成方法。具有相同或相似行为的对象可统一抽象为类。具有相同行为特征的类还可以抽象出虚基类或者是接口。  
    好处是更加地贴近现实，可以直观地分解问题；类的封装性好，类与类边界较为清晰,模块化更有利于开发与维护；interface的使用有利于代码的规范。类的继承也有利于代码的重用。  
    在读example代码时，position被作为对象抽象出来，对我造成了一定的困扰。position在直觉上更像是属性而不是对象，故对我而言，position与linable的交互部分的可读性就很差。不同的人对问题的抽象能力不一致，抽象的程度不一致，对问题的理解也不一致，就有可能导致其他人的代码对自己而言可读性太差。
# 任务二
受限于录屏文件大小限制，小兵个数只有64个，任务三则对应为8*8方阵
1. 类图  
    类图为 S191220100/uml/task2_class.pu
2. 排序可视化  
    实现了快速排序和选择排序，可视化结果连接如下  
    <https://asciinema.org/a/438686>  
    其中选择排序在先，快速排序在后
# 任务三
1. 类图  
    类图为 S191220100/uml/task3_class.pu  
    比任务二多了文件Matrix.java
2. 排序可视化  
    实现了快速排序和选择排序，可视化结果连接如下  
    <https://asciinema.org/a/438687>  
    其中快速排序在先，选择排序在后